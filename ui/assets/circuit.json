{"noir_version":"0.38.0+e784523a15c0c233a5a794f28498635b7ce86325","hash":9939465157112119270,"abi":{"parameters":[{"name":"signed_data","type":{"kind":"array","length":100,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signed_data_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"public"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"25":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"34":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8 = 256;\nglobal TWO_POW_16 = TWO_POW_8 * 256;\nglobal TWO_POW_24 = TWO_POW_16 * 256;\nglobal TWO_POW_32 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"36":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod schnorr;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod eddsa;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod ec;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(\n        crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y),\n    )\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"69":{"source":"use std::hash::sha256_var;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::RBN2048};\n// use string_search::{StringBody64, SubString32};\n\nglobal MAX_DATA_LENGTH: u32 = 100;\n\n\nfn main(\n  signed_data: [u8; MAX_DATA_LENGTH],\n  signed_data_len: u32,\n  pubkey_modulus_limbs: pub [Field; 18],\n  redc_params_limbs: [Field; 18],\n  signature_limbs: [Field; 18]\n) {       \n  let mut data_hash: [u8; 32] = sha256_var(signed_data, signed_data_len as u64);\n\n  // Construct RSA 2048 params\n  let params: BigNumParams<18, 2048> =\n      BigNumParams::new(false, pubkey_modulus_limbs, redc_params_limbs);\n\n  // Verify RSA signature\n  let signature: RBN2048 = RuntimeBigNum::from_array(params, signature_limbs);\n  assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n\n\n  // let haystack: StringBody64 = StringBody64::new(signed_data.storage(), signed_data.len());\n  // let needle: SubString32 = SubString32::new(city, city.len());\n  // let (result, match_position): (bool, u32) = haystack.substring_match(needle);\n  // assert(result);\n}\n","path":"/Users/saleel/Aztec/noir-bb-sample/circuits/src/main.nr"},"71":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    pub fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/params.nr"},"72":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    println(remainder);\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/expressions.nr"},"73":{"source":"use crate::params::BigNumParams as P;\n\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    }, unconstrained_ops::{__div, __mul, __udiv_mod},\n};\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/constrained_ops.nr"},"74":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/serialization.nr"},"76":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one: [Field; N] = __one::<N>();\n    let one_u60: U60Repr<N, 2> = U60Repr::from(one);\n    let exp_u60 = params.modulus_u60.sub(one_u60.add(one_u60));\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = unsafe { U60Repr::one() };\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut found_root = false;\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one) == false) {} else {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                found_root = true;\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    let result = if found_root {\n        std::option::Option::some(r)\n    } else {\n        std::option::Option::none()\n    };\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/unconstrained_ops.nr"},"77":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n    let mut partial_quotient: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..2 * N {\n        partial_quotient[i] = partial_quotient_full[i];\n    }\n    // quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus: [Field; 2 * N] = [0; 2 * N];\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus[i + j] += partial_quotient[i] * modulus[j];\n        }\n    }\n\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus[i + 1] += hi;\n        }\n    }\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (!lsb_is_one) {\n            result += 1;\n            target.shr1();\n        } else {\n            break;\n        }\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = unsafe { __add(params, target, one) };\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/unconstrained_helpers.nr"},"81":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut inp: _ = input;\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(inp[i]);\n\n        normalized[i] = lo;\n        inp[i + 1] += hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(inp[range - 1]);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/utils/split_bits.nr"},"82":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/utils/u60_representation.nr"},"117":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, mul, neg, sub,\n        udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    }, expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32> {\n    pub fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self;\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    pub fn modulus(self) -> Self;\n    pub fn modulus_bits() -> u32;\n    pub fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    pub fn get_limbs(self) -> [Field; N];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    pub fn __neg(self) -> Self;\n    // unconstrained\n    pub fn __add(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __div(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    pub fn __invmod(self) -> Self;\n    // unconstrained\n    pub fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_field(self);\n    pub fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    pub fn neg(self) -> Self;\n    pub fn add(lhs: Self, rhs: Self) -> Self {\n        lhs + rhs\n    }\n    pub fn sub(lhs: Self, rhs: Self) -> Self {\n        lhs - rhs\n    }\n    pub fn mul(lhs: Self, rhs: Self) -> Self {\n        lhs * rhs\n    }\n    pub fn div(lhs: Self, rhs: Self) -> Self {\n        lhs / rhs\n    }\n    pub fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    pub fn udiv(numerator: Self, divisor: Self) -> Self;\n    pub fn umod(numerator: Self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = unsafe { derive_from_seed::<_, MOD_BITS, _>(params, seed) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = unsafe { __derive_from_seed::<_, MOD_BITS, _>(params, seed) };\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = unsafe {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/runtime_bignum.nr"},"121":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir_rsav0.4.0/lib/src/rsa.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","directive_integer_quotient","directive_invert"]}