{"noir_version":"0.38.0+e784523a15c0c233a5a794f28498635b7ce86325","hash":13231645343556142176,"abi":{"parameters":[{"name":"signed_data","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signed_data_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"public"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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+JO1bt2E6ssGztO5c/q9ce5wDGCJ97V0Kq25czhS2uuzhOWf7Z9wOpwZ6ArHPwsnufdreLcDJ2DBiVhwBAtO+jk43m/hZCw45Wk4q9Xvgixs4FQsOA0KTnZYcDwWnIAFJ2LBESw4CQtOxoKDNStnrFk5Y83KBWtWLlizcsGalQvWrFywZuWCNSsXrFm5YM3KBWtWLlizcsWalSvWrFyxZuWKNStXrFm5Ys3KFWtWrlizcsWalSvWrNywZuWGNSs3rFm5Yc3KDWtWblizcsOalRvWrNywZuUGNSsXBzUrFwc1KxcHNSsXBzUrFwc1KxcHNSsXBzUrFwc1KxcHNSsXhzUre6xZ2WPNyh5rVvZYs7LHmpU91qzssWZljzUre6xZ2WPNygFrVg5Ys3LAmpUD1qwcsGblgDUrB6xZOWDNygFrVg5Ys3LEmpUj1qwcsWbliDUrR6xZOWLNyhFrVo5Ys3LEmpUj1qwsWLOyYM3KgjUrC9asLFizsmDNyoI1KwvWrCxYs7JgzcoJa1ZOWLNywpqVE9asnLBm5YQ1KyesWRnrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72FayzfQXrbF/BOttXsM72VayzfRXrbF/FOttXsc72VQc1K1ess30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfxTrbV7HO9lWss30V62xfffxAlBd5wfHVb+A8/ceKtb3giKsbOBULToOC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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"25":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"34":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8 = 256;\nglobal TWO_POW_16 = TWO_POW_8 * 256;\nglobal TWO_POW_24 = TWO_POW_16 * 256;\nglobal TWO_POW_32 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"36":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod schnorr;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod eddsa;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod ec;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(\n        crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y),\n    )\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"69":{"source":"use std::hash::sha256_var;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::RBN2048};\n// use string_search::{StringBody64, SubString32};\n\nglobal MAX_DATA_LENGTH: u32 = 20;\n\n\nfn main(\n  signed_data: [u8; MAX_DATA_LENGTH],\n  signed_data_len: u32,\n  pubkey_modulus_limbs: pub [Field; 18],\n  redc_params_limbs: [Field; 18],\n  signature_limbs: [Field; 18],\n  // revealed_data: pub [u8; 3],\n) {       \n  let mut data_hash: [u8; 32] = sha256_var(signed_data, signed_data_len as u64);\n\n  // Construct RSA 2048 params\n  let params: BigNumParams<18, 2048> =\n      BigNumParams::new(false, pubkey_modulus_limbs, redc_params_limbs);\n\n  // Verify RSA signature\n  let signature: RBN2048 = RuntimeBigNum::from_array(params, signature_limbs);\n  assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n\n\n  // let haystack: StringBody64 = StringBody64::new(signed_data, signed_data_len);\n  // let needle: SubString32 = SubString32::new(revealed_data, revealed_data.len());\n  // let (result, match_position): (bool, u32) = haystack.substring_match(needle);\n  // assert(result);\n}\n","path":"/Users/saleel/Aztec/noir-bb-sample/circuits/src/main.nr"},"71":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    pub fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/params.nr"},"72":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    println(remainder);\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/expressions.nr"},"73":{"source":"use crate::params::BigNumParams as P;\n\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    }, unconstrained_ops::{__div, __mul, __udiv_mod},\n};\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/constrained_ops.nr"},"74":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/serialization.nr"},"76":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one: [Field; N] = __one::<N>();\n    let one_u60: U60Repr<N, 2> = U60Repr::from(one);\n    let exp_u60 = params.modulus_u60.sub(one_u60.add(one_u60));\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = unsafe { U60Repr::one() };\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut found_root = false;\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one) == false) {} else {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                found_root = true;\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    let result = if found_root {\n        std::option::Option::some(r)\n    } else {\n        std::option::Option::none()\n    };\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/unconstrained_ops.nr"},"77":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n    let mut partial_quotient: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..2 * N {\n        partial_quotient[i] = partial_quotient_full[i];\n    }\n    // quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus: [Field; 2 * N] = [0; 2 * N];\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus[i + j] += partial_quotient[i] * modulus[j];\n        }\n    }\n\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus[i + 1] += hi;\n        }\n    }\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (!lsb_is_one) {\n            result += 1;\n            target.shr1();\n        } else {\n            break;\n        }\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = unsafe { __add(params, target, one) };\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/fns/unconstrained_helpers.nr"},"81":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut inp: _ = input;\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(inp[i]);\n\n        normalized[i] = lo;\n        inp[i + 1] += hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(inp[range - 1]);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/utils/split_bits.nr"},"82":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/utils/u60_representation.nr"},"117":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, mul, neg, sub,\n        udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    }, expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32> {\n    pub fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self;\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    pub fn modulus(self) -> Self;\n    pub fn modulus_bits() -> u32;\n    pub fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    pub fn get_limbs(self) -> [Field; N];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    pub fn __neg(self) -> Self;\n    // unconstrained\n    pub fn __add(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __div(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    pub fn __invmod(self) -> Self;\n    // unconstrained\n    pub fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_field(self);\n    pub fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    pub fn neg(self) -> Self;\n    pub fn add(lhs: Self, rhs: Self) -> Self {\n        lhs + rhs\n    }\n    pub fn sub(lhs: Self, rhs: Self) -> Self {\n        lhs - rhs\n    }\n    pub fn mul(lhs: Self, rhs: Self) -> Self {\n        lhs * rhs\n    }\n    pub fn div(lhs: Self, rhs: Self) -> Self {\n        lhs / rhs\n    }\n    pub fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    pub fn udiv(numerator: Self, divisor: Self) -> Self;\n    pub fn umod(numerator: Self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = unsafe { derive_from_seed::<_, MOD_BITS, _>(params, seed) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = unsafe { __derive_from_seed::<_, MOD_BITS, _>(params, seed) };\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = unsafe {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir-bignumv0.4.1/src/runtime_bignum.nr"},"121":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/Users/saleel/nargo/github.com/noir-lang/noir_rsav0.4.0/lib/src/rsa.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","directive_integer_quotient","directive_invert"]}